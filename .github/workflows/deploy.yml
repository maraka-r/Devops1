name: Deploy to EC2

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'  # ‚úÖ Utilise Node 20 comme dans le Dockerfile
          cache: 'npm'

      - name: Install dependencies
        run: npm ci  # ‚úÖ Utilise npm ci au lieu de npm i

      - name: Generate Prisma client
        run: npx prisma generate

      - name: Run database migrations
        run: npx prisma db push
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db

      - name: Build application
        run: npm run build

      - name: Run lint
        run: npm run lint

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'  # ‚úÖ Coh√©rence avec le test
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma client
        run: npx prisma generate

      - name: Build app
        run: npm run build

      - name: Build Docker image
        run: docker build -t maraka-app:${{ github.sha }} .

      - name: Save Docker image to tar
        run: docker save maraka-app:${{ github.sha }} | gzip > image.tar.gz

      - name: Set up SSH access to EC2
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.EC2_PRIVATE_KEY }}

      - name: Add EC2 to known hosts
        run: ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts

      - name: Upload artifacts to EC2
        run: |
          scp image.tar.gz ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:~/
          scp docker-compose.yml ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:~/
          scp prometheus.yml ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:~/
          scp alertmanager.yml ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:~/
          scp -r grafana ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:~/
          # ‚úÖ Upload du script sync-env.sh
          scp sync-env.sh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:~/app/ || echo "sync-env.sh non trouv√©, sera cr√©√© sur le serveur"

      - name: Deploy on EC2
        run: |
          ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} << 'EOF'
            set -e

            echo "üöÄ D√©but du d√©ploiement..."

            # Cr√©er r√©pertoire app si n√©cessaire
            mkdir -p ~/app

            # ‚úÖ ARR√äTER TOUS LES CONTENEURS EN PREMIER
            echo "üõë Arr√™t des conteneurs existants..."
            cd ~/app
            docker-compose down --remove-orphans 2>/dev/null || true
            
            # ‚úÖ Nettoyer explicitement les conteneurs probl√©matiques
            docker rm -f app-app-1 app-db-1 app-grafana-1 app-prometheus-1 app-alertmanager-1 app-node-exporter-1 app-postgres-exporter-1 2>/dev/null || true

            # ‚úÖ Charger l'image APR√àS avoir arr√™t√© les conteneurs
            echo "üê≥ Chargement de l'image Docker..."
            cd ~/
            gunzip -c ~/image.tar.gz | docker load

            # Copier les fichiers dans ~/app
            echo "üìÅ Copie des fichiers de configuration..."
            mv ~/docker-compose.yml ~/app/ 2>/dev/null || true
            mv ~/prometheus.yml ~/app/ 2>/dev/null || true
            mv ~/alertmanager.yml ~/app/ 2>/dev/null || true
            
            # Supprimer et remplacer le r√©pertoire grafana
            rm -rf ~/app/grafana
            mv ~/grafana ~/app/ 2>/dev/null || true
            
            mv ~/image.tar.gz ~/app/ 2>/dev/null || true

            cd ~/app

            # ‚úÖ Cr√©er le script sync-env.sh s'il n'existe pas
            if [ ! -f "./sync-env.sh" ]; then
              echo "üìù Cr√©ation du script sync-env.sh..."
              cat > sync-env.sh << 'SCRIPT_EOF'
            #!/bin/bash
            CONTAINER_NAME=$1
            ENV_FILE=".env"

            if [ -z "$CONTAINER_NAME" ]; then
              echo "‚ùå Utilisation : ./sync-env.sh <nom-du-conteneur>"
              exit 1
            fi

            if [ ! -f "$ENV_FILE" ]; then
              echo "‚ùå Fichier $ENV_FILE introuvable."
              exit 1
            fi

            echo "üì¶ Injection des variables dans le conteneur: $CONTAINER_NAME"

            # Arr√™ter le conteneur
            docker stop "$CONTAINER_NAME"

            # Corriger le fichier .env (r√©soudre les variables)
            TEMP_ENV="/tmp/resolved.env"
            > "$TEMP_ENV"

            while IFS='=' read -r key value; do
              if [[ "$key" =~ ^#.*$ || -z "$key" ]]; then
                continue
              fi
              
              key=$(echo "$key" | xargs)
              value=$(echo "$value" | sed -e 's/^"//' -e 's/"$//' | xargs)
              
              # R√©soudre les variables dans la valeur
              if [[ "$value" == *'${'* ]]; then
                while IFS='=' read -r sub_key sub_value; do
                  if [[ ! "$sub_key" =~ ^#.*$ && ! -z "$sub_key" ]]; then
                    sub_key=$(echo "$sub_key" | xargs)
                    sub_value=$(echo "$sub_value" | sed -e 's/^"//' -e 's/"$//' | xargs)
                    value=${value//\$\{$sub_key\}/$sub_value}
                  fi
                done < "$ENV_FILE"
              fi
              
              echo "$key=$value" >> "$TEMP_ENV"
            done < "$ENV_FILE"

            # Red√©marrer le conteneur avec les nouvelles variables
            CONTAINER_ID=$(docker ps -aq --filter "name=$CONTAINER_NAME")
            if [ ! -z "$CONTAINER_ID" ]; then
              IMAGE=$(docker inspect --format='{{.Config.Image}}' "$CONTAINER_ID")
              docker rm -f "$CONTAINER_NAME" 2>/dev/null
              docker run -d \
                --name "$CONTAINER_NAME" \
                --network "$(basename $(pwd))_default" \
                --env-file "$TEMP_ENV" \
                -p 3000:3000 \
                "$IMAGE"
            fi

            rm -f "$TEMP_ENV"
            echo "‚úÖ Variables inject√©es avec succ√®s!"
            SCRIPT_EOF
              chmod +x sync-env.sh
            fi

            # Modifier docker-compose.yml pour utiliser l'image taggu√©e
            sed -i 's|image: maraka-app:.*|image: maraka-app:${{ github.sha }}|' docker-compose.yml

            # Supprimer nginx.conf s'il est mentionn√©
            sed -i '/nginx.conf/d' docker-compose.yml 2>/dev/null || true

            # ‚úÖ D√âMARRER tous les conteneurs
            echo "üèÉ‚Äç‚ôÇÔ∏è Lancement des conteneurs..."
            docker-compose up -d

            # ‚úÖ Attendre que les conteneurs soient pr√™ts
            echo "‚è±Ô∏è Attente du d√©marrage des conteneurs..."
            sleep 20

            echo "üìä Statut des conteneurs:"
            docker-compose ps

            # ‚úÖ MIGRATIONS PRISMA
            echo "üóÑÔ∏è Ex√©cution des migrations Prisma..."
            
            # Trouver le conteneur app
            APP_CONTAINER=$(docker-compose ps -q app)
            if [ ! -z "$APP_CONTAINER" ]; then
              APP_NAME=$(docker ps --filter "id=$APP_CONTAINER" --format "{{.Names}}")
              echo "Conteneur app trouv√©: $APP_NAME"
              
              # Attendre que la DB soit pr√™te
              echo "Attente de la base de donn√©es..."
              for i in {1..10}; do
                if docker exec $APP_NAME timeout 10 pg_isready -h db -p 5432 -U postgres > /dev/null 2>&1; then
                  echo "‚úÖ Base de donn√©es accessible"
                  break
                else
                  echo "‚è≥ Tentative $i/10 - DB pas encore pr√™te..."
                  sleep 5
                fi
              done

              # Ex√©cuter les migrations
              if docker exec $APP_NAME npx prisma db push --accept-data-loss; then
                echo "‚úÖ Sch√©ma Prisma synchronis√©"
              else
                echo "‚ùå Erreur lors de la synchronisation Prisma"
                docker logs $APP_NAME --tail=20
              fi

              # ‚úÖ Injection des variables d'environnement APR√àS les migrations
              echo "üîß Injection des variables d'environnement..."
              if [ -f "./sync-env.sh" ]; then
                ./sync-env.sh "$APP_NAME"
              else
                echo "‚ö†Ô∏è Script sync-env.sh non trouv√©"
              fi

            else
              echo "‚ùå Conteneur app non trouv√©"
            fi

            # ‚úÖ Tests de sant√©
            echo "üß™ Tests de sant√©..."
            sleep 10
            
            for i in {1..5}; do
              if curl -f http://localhost:3000 > /dev/null 2>&1; then
                echo "‚úÖ Application accessible sur le port 3000"
                break
              else
                echo "‚è≥ Test $i/5 - App pas encore pr√™te..."
                sleep 10
              fi
            done

            # Nettoyage
            echo "üßπ Nettoyage..."
            docker image prune -f
            rm -f ~/deploy.tar.gz ~/image.tar.gz 2>/dev/null || true
            rm -rf ~/deploy 2>/dev/null || true

            echo "‚úÖ D√©ploiement termin√© avec succ√®s!"
          EOF